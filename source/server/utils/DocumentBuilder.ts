/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as path from "path";
import { promises as fs } from "fs";

import clone from "@ff/core/clone";
import uniqueId from "@ff/core/uniqueId";

import { IDocument, INode, IScene, ICamera } from "../types/document";
import { IArticle, IMeta } from "../types/meta";
import { ISetup, ITours, ITour, IState } from "../types/setup";

import {
    IModel,
    IAnnotation,
    IDerivative,
    TDerivativeUsage,
    TDerivativeQuality,
    IAsset,
    TAssetType,
    TMapType,
} from "../types/model";

////////////////////////////////////////////////////////////////////////////////

export default class DocumentBuilder
{
    protected static readonly defaultDocument: IDocument = {
        asset: {
            "type": "application/si-dpo-3d.document+json",
            "version": "1.0",
            "generator": "Cook",
            "copyright": "(c) Smithsonian Institution. All rights reserved."
        },
        "scene": 0,
        "scenes": [{
            "name": "Scene",
            "units": "cm",
        }],
    };

    document: IDocument = null;
    baseDir: string = "";

    constructor(baseDir: string, document?: IDocument)
    {
        this.baseDir = baseDir;
        this.document = document ? document : clone(DocumentBuilder.defaultDocument);
    }

    initialize()
    {
        this.document = clone(DocumentBuilder.defaultDocument);
    }

    getMainScene(): IScene
    {
        return this.document.scenes[this.document.scene];
    }

    createNode(parent: INode): INode
    {
        const nodes = this.document.nodes = this.document.nodes || [];
        const children = parent.children = parent.children || [];
        children.push(nodes.length);

        const node: INode = {};
        nodes.push(node);
        return node;
    }

    getOrCreateCamera(node: INode): ICamera
    {
        if (node.camera !== undefined) {
            return this.document.cameras[node.camera];
        }

        const cameras = this.document.cameras = this.document.cameras || [];
        node.camera = cameras.length;

        const camera: ICamera = {
            type: "perspective",
        };

        cameras.push(camera);
        return camera;
    }

    createRootNode(scene?: IScene): INode
    {
        scene = scene || this.getMainScene();
        const nodes = this.document.nodes = this.document.nodes || [];
        const children = scene.nodes = scene.nodes || [];
        children.push(nodes.length);

        const node: INode = {};
        nodes.push(node);
        return node;
    }

    getOrCreateSetup(scene: IScene): ISetup
    {
        if (scene.setup !== undefined) {
            return this.document.setups[scene.setup];
        }

        const setups = this.document.setups = this.document.setups || [];
        scene.setup = setups.length;

        const setup: ISetup = {};
        setups.push(setup);
        return setup;
    }

    getOrCreateMeta(node: INode | IScene): IMeta
    {
        if (node.meta !== undefined) {
            return this.document.metas[node.meta];
        }

        const metas = this.document.metas = this.document.metas || [];
        node.meta = metas.length;

        const meta: IMeta = {};
        metas.push(meta);
        return meta;
    }

    getOrCreateModel(node: INode): IModel
    {
        if (node.model !== undefined) {
            return this.document.models[node.model];
        }

        const models = this.document.models = this.document.models || [];
        node.model = models.length;

        const model: IModel = {
            units: "cm",
            derivatives: [],
        };

        models.push(model);
        return model;
    }

    findNodesByModel(model: IModel): INode[]
    {
        const nodes = this.document.nodes;
        if (!nodes) {
            return [];
        }

        const models = this.document.models;
        if (!models) {
            return [];
        }

        return nodes.filter(node => models[node.model] === model);
    }

    getCamera(index: number): ICamera | undefined
    {
        return this.document.cameras ? this.document.cameras[index] : undefined;
    }

    findNodeByCamera(camera: ICamera): INode
    {
        const nodes = this.document.nodes;
        if (!nodes) {
            return null;
        }

        const cameras = this.document.cameras;
        if (!cameras) {
            return null;
        }

        return nodes.find(node => cameras[node.camera] === camera);
    }

    findSceneBySetup(setup: ISetup): IScene | undefined
    {
        const scenes = this.document.scenes;
        if (!scenes) {
            return undefined;
        }

        const setups = this.document.setups;
        if (!setups) {
            return undefined;
        }

        return scenes.filter(scene => setups[scene.setup] === setup)[0];
    }

    createArticle(node: IScene | INode, uri: string): IArticle
    {
        const meta = this.getOrCreateMeta(node);
        const articles = meta.articles = meta.articles || [];
        const article: IArticle = {
            id: uniqueId(),
            uri
        };

        articles.push(article);
        return article;
    }

    addArticle(node: IScene | INode, article: IArticle): IArticle
    {
        const meta = this.getOrCreateMeta(node);
        const articles = meta.articles = meta.articles || [];
        articles.push(article);
        return article;
    }

    createAnnotation(model: IModel): IAnnotation
    {
        const annotations = model.annotations = model.annotations || [];
        const annotation: IAnnotation = {
            id: uniqueId()
        };

        annotations.push(annotation);
        return annotation;
    }

    createTour(setup: ISetup, title: string): ITour
    {
        const scene = this.findSceneBySetup(setup);
        const sceneIndex = this.document.scenes.indexOf(scene);
        const scenePath = `scenes/${sceneIndex}/`;

        setup.snapshots = setup.snapshots || {
            features: ["reader", "viewer", "navigation"],
            targets: [
                `${scenePath}setup/reader/enabled`,
                `${scenePath}setup/reader/articleId`,
                `${scenePath}setup/navigation/orbit`,
                `${scenePath}setup/navigation/offset`,
                `${scenePath}setup/viewer/annotationsVisible`,
                `${scenePath}setup/viewer/activeAnnotation`,
                `${scenePath}setup/viewer/activeTags`,
                `${scenePath}setup/viewer/shader`,
                `${scenePath}setup/viewer/exposure`
            ],
            states: []
        };


        const tours: ITours = setup.tours = setup.tours || [];
        const tour: ITour = {
            title,
            steps: []
        };

        tours.push(tour);
        return tour;
    }

    createSnapshot(setup: ISetup, tour: ITour, title: string): IState
    {
        const id = uniqueId(6);

        const step = { id, title };
        tour.steps.push(step);

        const state = { id, values: [], duration: 1.5, curve: "EaseOutQuad", threshold: 0.5 };
        setup.snapshots.states.push(state);
        return state;
    }

    getOrCreateDerivative(model: IModel, quality: TDerivativeQuality, usage: TDerivativeUsage = "Web3D"): IDerivative
    {
        let derivative = model.derivatives.find(
            derivative => derivative.usage === usage && derivative.quality === quality);

        if (!derivative) {
            derivative = {
                quality,
                usage,
                assets: [],
            };

            model.derivatives.push(derivative);
        }

        return derivative;
    }

    async setModelAsset(derivative: IDerivative, uri: string, numFaces?: number, mapSize?: number): Promise<IAsset>
    {
        return this.setAsset(derivative, "Model", uri).then(asset => {
            if (numFaces > 0) {
                asset.numFaces = numFaces;
            }
            if (mapSize > 0) {
                asset.imageSize = mapSize;
            }

            return asset;
        });
    }

    async setGeometryAsset(derivative: IDerivative, uri: string, numFaces?: number): Promise<IAsset>
    {
        return this.setAsset(derivative, "Geometry", uri).then(asset => {
            if (numFaces > 0) {
                asset.numFaces = numFaces;
            }

            return asset;
        });
    }

    async setTextureAsset(derivative: IDerivative, uri: string, mapType: TMapType,  mapSize?: number): Promise<IAsset>
    {
        return this.setAsset(derivative, "Texture", uri).then(asset => {
            asset.mapType = mapType;
            if (mapSize > 0) {
                asset.imageSize = mapSize;
            }

            return asset;
        });
    }

    async setAsset(derivative: IDerivative, type: TAssetType, uri: string): Promise<IAsset>
    {
        const assetPath = path.resolve(this.baseDir, uri);

        let asset = derivative.assets.find(asset => asset.type === type);

        if (!asset) {
            asset = {
                uri,
                type
            };

            derivative.assets.push(asset);
        }
        else {
            asset.uri = uri;
        }

        return fs.stat(assetPath).then(stats => {
            asset.byteSize = stats.size;
        })
        .catch(() => {})
        .then(() => asset);
    }
}